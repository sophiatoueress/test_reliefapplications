import { ReplaySubject } from 'rxjs';
import { Injectable, NgZone, ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, Renderer2, NgModule, defineInjectable, inject } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
import * as ɵngcc0 from '@angular/core';
function win() {
    return window;
}
/**
 * @return {?}
 */
function YouTubeRef() {
    return win()['YT'];
}
/**
 * @return {?}
 */
function YouTubePlayerRef() {
    return YouTubeRef().Player;
}
/** @type {?} */
const defaultSizes = {
    height: 270,
    width: 367
};
class YoutubePlayerService {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        this.ytApiLoaded = false;
        this.api = new ReplaySubject(1);
        this.createApi();
    }
    /**
     * @param {?} options
     * @return {?}
     */
    loadPlayerApi(options) {
        /** @type {?} */
        const doc = win().document;
        if (!this.ytApiLoaded) {
            this.ytApiLoaded = true;
            /** @type {?} */
            const playerApiScript = doc.createElement('script');
            playerApiScript.type = 'text/javascript';
            playerApiScript.src = `${options.protocol}://www.youtube.com/iframe_api`;
            doc.body.appendChild(playerApiScript);
        }
    }
    /**
     * @param {?} elementId
     * @param {?} outputs
     * @param {?} sizes
     * @param {?=} videoId
     * @param {?=} playerVars
     * @return {?}
     */
    setupPlayer(elementId, outputs, sizes, videoId = '', playerVars) {
        /** @type {?} */
        const createPlayer = (/**
         * @return {?}
         */
        () => {
            if (YouTubePlayerRef) {
                this.createPlayer(elementId, outputs, sizes, videoId, playerVars);
            }
        });
        this.api.subscribe(createPlayer);
    }
    /**
     * @param {?} player
     * @return {?}
     */
    play(player) {
        player.playVideo();
    }
    /**
     * @param {?} player
     * @return {?}
     */
    pause(player) {
        player.pauseVideo();
    }
    /**
     * @param {?} media
     * @param {?} player
     * @return {?}
     */
    playVideo(media, player) {
        /** @type {?} */
        const id = media.id.videoId ? media.id.videoId : media.id;
        player.loadVideoById(id);
        this.play(player);
    }
    /**
     * @param {?} player
     * @return {?}
     */
    isPlaying(player) {
        // because YT is not loaded yet 1 is used - YT.PlayerState.PLAYING
        /** @type {?} */
        const isPlayerReady = player && player.getPlayerState;
        /** @type {?} */
        const playerState = isPlayerReady ? player.getPlayerState() : {};
        /** @type {?} */
        const isPlayerPlaying = isPlayerReady
            ? playerState !== YouTubeRef().PlayerState.ENDED &&
                playerState !== YouTubeRef().PlayerState.PAUSED
            : false;
        return isPlayerPlaying;
    }
    /**
     * @param {?} elementId
     * @param {?} outputs
     * @param {?} sizes
     * @param {?=} videoId
     * @param {?=} playerVars
     * @return {?}
     */
    createPlayer(elementId, outputs, sizes, videoId = '', playerVars = {}) {
        /** @type {?} */
        const playerSize = {
            height: sizes.height || defaultSizes.height,
            width: sizes.width || defaultSizes.width
        };
        /** @type {?} */
        const ytPlayer = YouTubePlayerRef();
        return new ytPlayer(elementId, Object.assign({}, playerSize, { events: {
                onReady: (/**
                 * @param {?} ev
                 * @return {?}
                 */
                (ev) => {
                    this.zone.run((/**
                     * @return {?}
                     */
                    () => outputs.ready && outputs.ready.next(ev.target)));
                }),
                onStateChange: (/**
                 * @param {?} ev
                 * @return {?}
                 */
                (ev) => {
                    this.zone.run((/**
                     * @return {?}
                     */
                    () => outputs.change && outputs.change.next(ev)));
                })
            }, playerVars,
            videoId }));
    }
    /**
     * @param {?} player
     * @param {?} isFullScreen
     * @return {?}
     */
    toggleFullScreen(player, isFullScreen) {
        let { height, width } = defaultSizes;
        if (!isFullScreen) {
            height = window.innerHeight;
            width = window.innerWidth;
        }
        player.setSize(width, height);
    }
    // adpoted from uid
    /**
     * @return {?}
     */
    generateUniqueId() {
        /** @type {?} */
        const len = 7;
        return Math.random()
            .toString(35)
            .substr(2, len);
    }
    /**
     * @private
     * @return {?}
     */
    createApi() {
        /** @type {?} */
        const onYouTubeIframeAPIReady = (/**
         * @return {?}
         */
        () => {
            if (win()) {
                this.api.next(YouTubeRef());
            }
        });
        win()['onYouTubeIframeAPIReady'] = onYouTubeIframeAPIReady;
    }
}
YoutubePlayerService.ɵfac = function YoutubePlayerService_Factory(t) { return new (t || YoutubePlayerService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
YoutubePlayerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: YoutubePlayerService, factory: YoutubePlayerService.ɵfac, providedIn: 'root' });
/** @nocollapse */
YoutubePlayerService.ctorParameters = () => [
    { type: NgZone }
];
/** @nocollapse */ YoutubePlayerService.ngInjectableDef = defineInjectable({ factory: function YoutubePlayerService_Factory() { return new YoutubePlayerService(inject(NgZone)); }, token: YoutubePlayerService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(YoutubePlayerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class YoutubePlayerComponent {
    /**
     * @param {?} playerService
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(playerService, elementRef, renderer) {
        this.playerService = playerService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.videoId = '';
        this.height = defaultSizes.height;
        this.width = defaultSizes.width;
        /**
         * \@description sets the protocol by the navigator object
         * if there is no window, it sets a default http protocol
         * unless the protocol is set from outside
         */
        this.protocol = this.getProtocol();
        this.playerVars = {};
        // player created and initialized - sends instance of the player
        this.ready = new EventEmitter();
        // state change: send the YT event with its state
        this.change = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const htmlId = this.playerService.generateUniqueId();
        /** @type {?} */
        const playerSize = { height: this.height, width: this.width };
        /** @type {?} */
        const container = this.renderer.selectRootElement('#yt-player-ngx-component');
        this.renderer.setAttribute(container, 'id', htmlId);
        this.playerService.loadPlayerApi({
            protocol: this.protocol
        });
        this.playerService.setupPlayer(htmlId, {
            change: this.change,
            ready: this.ready
        }, playerSize, this.videoId, this.playerVars);
    }
    /**
     * @return {?}
     */
    getProtocol() {
        /** @type {?} */
        const hasWindow = window && window.location;
        /** @type {?} */
        const protocol = hasWindow
            ? window.location.protocol.replace(':', '')
            : 'http';
        return protocol;
    }
}
YoutubePlayerComponent.ɵfac = function YoutubePlayerComponent_Factory(t) { return new (t || YoutubePlayerComponent)(ɵngcc0.ɵɵdirectiveInject(YoutubePlayerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
YoutubePlayerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YoutubePlayerComponent, selectors: [["youtube-player"]], inputs: { videoId: "videoId", height: "height", width: "width", protocol: "protocol", playerVars: "playerVars" }, outputs: { ready: "ready", change: "change" }, decls: 1, vars: 0, consts: [["id", "yt-player-ngx-component"]], template: function YoutubePlayerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
YoutubePlayerComponent.ctorParameters = () => [
    { type: YoutubePlayerService },
    { type: ElementRef },
    { type: Renderer2 }
];
YoutubePlayerComponent.propDecorators = {
    videoId: [{ type: Input }],
    height: [{ type: Input }],
    width: [{ type: Input }],
    protocol: [{ type: Input }],
    playerVars: [{ type: Input }],
    ready: [{ type: Output }],
    change: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(YoutubePlayerComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'youtube-player',
                template: `
    <div id="yt-player-ngx-component"></div>
  `
            }]
    }], function () { return [{ type: YoutubePlayerService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { videoId: [{
            type: Input
        }], height: [{
            type: Input
        }], width: [{
            type: Input
        }], protocol: [{
            type: Input
        }], playerVars: [{
            type: Input
        }], ready: [{
            type: Output
        }], change: [{
            type: Output
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxYoutubePlayerModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxYoutubePlayerModule,
            providers: [YoutubePlayerService]
        };
    }
}
NgxYoutubePlayerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxYoutubePlayerModule });
NgxYoutubePlayerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxYoutubePlayerModule_Factory(t) { return new (t || NgxYoutubePlayerModule)(); }, providers: [YoutubePlayerService], imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxYoutubePlayerModule, { declarations: [YoutubePlayerComponent], exports: [YoutubePlayerComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxYoutubePlayerModule, [{
        type: NgModule,
        args: [{
                declarations: [YoutubePlayerComponent],
                imports: [],
                providers: [YoutubePlayerService],
                exports: [YoutubePlayerComponent]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { win, YouTubeRef, YouTubePlayerRef, defaultSizes, YoutubePlayerService, YoutubePlayerComponent, NgxYoutubePlayerModule };

//# sourceMappingURL=ngx-youtube-player.js.map